# Create Main Layout

Create a new folder called `src/layouts`

## File: layouts/Layout.tsx

Then create a new file called `Layout.tsx`

```tsx
import React from "react";
import { Outlet, useNavigate } from "react-router-dom";

const Layout: React.FC = () => {
  const navigate = useNavigate();

  const handleLogout = () => {
    localStorage.removeItem("accessToken");
    localStorage.removeItem("user");
    navigate("/login");
  };

  return (
    <div className="min-h-screen bg-gray-100">
      {/* Navbar */}
      <nav className="bg-white shadow-md">
        <div className="w-full px-2 sm:px-6 py-4 flex justify-between items-center">
          <h1
            className="text-lg font-bold text-indigo-600 cursor-pointer"
            onClick={() => navigate("/dashboard")}
          >
            Document Portal
          </h1>

          <div className="flex gap-6 items-center">
            <button
              onClick={() => navigate("/dashboard")}
              className="text-gray-700 hover:text-indigo-600"
            >
              Dashboard
            </button>

            <button
              onClick={() => navigate("/documents")}
              className="text-gray-700 hover:text-indigo-600"
            >
              Documents
            </button>

            <button
              onClick={handleLogout}
              className="bg-red-500 px-4 py-1 rounded text-white hover:bg-red-600"
            >
              Logout
            </button>
          </div>
        </div>
      </nav>

      {/* Page Content */}
      <main className="w-full px-6 py-8">
        <Outlet />
      </main>
    </div>
  );
};

export default Layout;
```

---

## Create Protected Route

### File: routes/ProtectedRoute.tsx

```tsx
import { Navigate } from "react-router-dom";
import React from "react";

interface Props {
  children: React.ReactNode;
}

const ProtectedRoute: React.FC<Props> = ({ children }) => {
  const token = localStorage.getItem("accessToken");

  if (!token) {
    return <Navigate to="/login" replace />;
  }

  return <>{children}</>;
};

export default ProtectedRoute;
```

**Why Use a Protected Route**

A Protected Route ensures that only authenticated users can access certain pages in the application.

- Without it, anyone could directly type /dashboard or /documents in the URL and access sensitive content.
- With the ProtectedRoute component, the app checks if the user has a valid token in localStorage.
- If the token exists â†’ the user can access the page.
- If not â†’ the user is redirected to the /login page.

This adds a security layer and prevents unauthorized access to company documents.

---

### File: App.tsx

Update current App.tsx from:

```tsx
import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import LoginPage from "./pages/LoginPage";
import Dashboard from "./pages/Dashboard";
import Document from "./pages/Document";
import UploadDocument from "./pages/UploadDocument";
import ViewDocument from "./pages/ViewDocument";
import { Navigate } from "react-router-dom";

const App: React.FC = () => {
  const isAuthenticated = !!localStorage.getItem("accessToken");
  return (
    <Router>
      <Routes>
        <Route path="/login" element={<LoginPage />} />
        <Route
          path="/dashboard"
          element={
            isAuthenticated ? <Dashboard /> : <Navigate to="/login" replace /> // Redirect to login if not authenticated
          }
        />
        <Route
          path="/documents"
          element={
            isAuthenticated ? <Document /> : <Navigate to="/login" replace />
          }
        />
        <Route
          path="/documents/upload"
          element={
            isAuthenticated ? (
              <UploadDocument />
            ) : (
              <Navigate to="/login" replace />
            )
          }
        />
        <Route
          path="/documents/:id"
          element={
            isAuthenticated ? (
              <ViewDocument />
            ) : (
              <Navigate to="/login" replace />
            )
          }
        />
      </Routes>
    </Router>
  );
};

export default App;
```

To:

```tsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
import LoginPage from "./pages/LoginPage";
import Dashboard from "./pages/Dashboard";
import Document from "./pages/Document";
import UploadDocument from "./pages/UploadDocument";
import ViewDocument from "./pages/ViewDocument";

import Layout from "./layouts/Layout";
import ProtectedRoute from "./routes/ProtectedRoute";

function App() {
  return (
    <BrowserRouter>
      <Routes>
        {/* Public Route */}
        <Route path="/login" element={<LoginPage />} />

        {/* Protected Routes */}
        <Route
          element={
            <ProtectedRoute>
              <Layout />
            </ProtectedRoute>
          }
        >
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/documents" element={<Document />} />
          <Route path="/documents/upload" element={<UploadDocument />} />
          <Route path="/documents/:id" element={<ViewDocument />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}

export default App;
```

---

Lastly we remove logout button in Dashboard.tsx

### File: Dashboard.tsx

```tsx
// ðŸ”¥ Logout Handler
const handleLogout = () => {
  localStorage.removeItem("user");
  localStorage.removeItem("accessToken");
  navigate("/login");
};
{
  /* Logout Button */
}
<button
  onClick={handleLogout}
  className="rounded-lg bg-red-500 px-4 py-2 text-sm font-semibold text-white shadow transition hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2"
>
  Logout
</button>;
```

---

## NOTES:

Why We Changed App.tsx

Before, App.tsx included authentication checks inside each route:

```tsx
<Route
  path="/dashboard"
  element={isAuthenticated ? <Dashboard /> : <Navigate to="/login" replace />}
/>
```

Problems with this approach:

- Repetition: Each protected route needed its own isAuthenticated check.
- Navbar duplication: Pages like Dashboard and Documents had separate logout buttons.
- Harder maintenance: Adding a new protected page meant repeating the same authentication logic.

Refactor Approach:

We wrapped all protected routes inside <ProtectedRoute> and <Layout>:

```tsx
<Route
  element={
    <ProtectedRoute>
      <Layout />
    </ProtectedRoute>
  }
>
  <Route path="/dashboard" element={<Dashboard />} />
  <Route path="/documents" element={<Document />} />
</Route>
```

Benefits:

- Centralized authentication check: Only one place to control access.
- Consistent layout: Navbar and page structure are shared across all pages.
- Easier maintenance: Adding new pages automatically inherits protection and layout.

Summary:

Using ProtectedRoute secures the application, and restructuring App.tsx makes the code cleaner, maintainable, and scalable.

---
